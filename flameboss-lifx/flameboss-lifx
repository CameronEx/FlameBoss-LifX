#!/usr/bin/python3
# -*- coding: utf-8 -*-

import configparser
import requests
import logging


class UnnamedModule():
    """
    One day, this might link a flame Boss controller to a LIFX bulb.
    To do:
      LIFX integration
      Logic to decide light colours
    """

    def __init__():
        """
        Initialises script
        """

        logger.debug("Initialising UnnamedModule.")
        self.API_BASE = "https://myflameboss.com/api/v1"
        self.lan = LifxLAN()

        logger.debug("Loading configuration from file.")
        self.load_settings()
        try:
            if not self.device_id:
                raise valueError
        except valueError:
            self.DEVICE_ID = input("Enter the Flame Boss device ID: ")
        self.run()

    def load_settings(self):
        """
        Loads previously saved settings from config file
        """

        # Setup the config parser
        logger.debug("Setting up the config parser.")
        config = configparser.ConfigParser()
        config_dir = os.path.expanduser("~/.config/UnnamedModule/")
        config_file = config_dir + "config.ini"

        # Ensure the config directory and file exists, if not, create defaults
        logger.debug("Checking if the configuration directory exists.")
        if not os.path.exists(config_dir):
            logger.info("Configuration directory Does not exist. Creating it.")
            os.makedirs(config_dir)
        else:
            logger.debug("Configuration directory exists.")

        logger.debug("Checking if the configuration file exists.")
        if not config.read(config_file):
            logger.info("Configuration file did not exist, creating one with defaults.")
            default_config = { "device_id": "",
                               "poll_interval": 300
                             }
            logger.debug("Default config is: {}".format(default_config))
            config['DEFAULT'] = default_config
            with open(config_file, "w") as new_file:
                logger.debug("Saving configuration file to {}.".format(config_file))
                config.write(new_file)
        else:
            logger.debug("It does.")

        # Read the config file and set state
        # FIXME: Handle the event of missing configuration
        logger.info("Loading configuration.")
        self.device_id = config["DEFAULT"]["device_id"]
        logger.debug("Falme Boss controller device ID: {}".format(self.device_id))
        self.poll_interval = config["DEFAULT"]["poll_interval"]
        logger.debug("API poll interval: {}".format(self.poll_interval))

    def run(self):
        """
        Scripts the logic for this program.
        """
        self.get_device_info()
        self.get_cook_info()

    def get_device_info(self):
        """
        Checks if the controller is online, saves info if it is
        """
        headers = { "X-API-VERSION": "2" }
        uri = "/devices/{}".format(self.device_id)
        target = API_BASE + uri
        try:
            response = requests.get(target, headers=headers)
        except ConnectionError:
            logging.error("Unable to connect to API.")

        if response.status_code == 200:
            if response.json()['online']:
                self.temp_alarm_range = response.json()['config']['Pit_Alarm_Range_tdc']
                self.cook_id = response.json()['most_recent_cook']['id']
        else:
            logger.error("Received an unexpected response from the API.")
            logger.error("Unable to update device information.")
            logger.debug("API HTTP status code was: {}".format(response.status_code))
            logger.debug("Content of response was:\n{}".format(response.text))
            return False

    def get_cook_info(self):
        """
        Gets current cook info, uses cook_id from self.get_device_info
        """

        headers = { "X-API-VERSION": "2" }
        uri = "/cook/{}".format(self.cook_id)
        target = API_BASE + uri
        try:
            response = requests.get(target, headers=headers)
        except ConnectionError:
            logging.error("Unable to connect to API.")

        if response.status_code = 200:
            self.pit_temp_target = response.json()['data'][-1]['set_temp']
            self.pit_temp_current = response.json()['data'][-1]['pit_temp']


# Logger config
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
ch.setFormatter(formatter)
logger.addHandler(ch)

if __name__ == "__main__":
    UnnamedModule().run()
